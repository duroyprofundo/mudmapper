<!DOCTYPE html>
<html>
<body style="background-color:white;">
<head>
<title>MUD Mapper</title>

 
<script type="text/javascript">
/*
 * MUD Mapper
 * Designed for mapping MUDs / Dungeons
 *
 * Written for HTML5 Canvas
 * Based on Virtual Graph Paper by Garrett Bartley
 * http://www.garrettbartley.com/graphpaper.html
 *
 */

// Declare global variables
var global;
var actions;
var canvas;
var ctx;
var shape;

// Use Debugger.log(string) to print out log messages to console
var Debugger = function () { };
Debugger.log = function (message) {
   try {
      console.log(message);
   } catch (exception) {
      return;
   }
}

// Called when everything is ready
function BodyLoad() {
	canvas = document.getElementById('canvas');

	// Set up the canvas context (ctx)
	ctx = canvas.getContext('2d');
	
	// Set some canvas properties
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	canvas.w = canvas.width;	// short-hand
	canvas.h = canvas.height;	// short-hand
	canvas.mousedown = false;
		
	// Global variables object and associated functions
	global = {
		version: 1,
		objects: [], 	
		spacing: 16,
		color: 'Black', 
		title: '',
		selected: -1,	// currently selected object (-1 = none)
		drawGraphPaper: true,

		// Only convert the settings we want save to JSON
		toJSON: function () {
        	return {
        		version: this.version,
            	objects: this.objects,
            	spacing: this.spacing,
            	title: this.title
        	}
    	},

		// Add a new object (square/line)
		addObject: function(x1,y1,x2,y2,type) {
			this.selected = this.objects.length;

			this.objects[this.selected] = {
				x1: x1,
				y1: y1,
				x2: x2,
				y2: y2,
				type: type,
				color: 'Black', // Reset color, label and subscript when adding new object
				label: '',
				sub: '',
				subpos: 'middle'
			}

			// Update the color and label values
			document.getElementById('color').value = 'Black';
			document.getElementById('label').value = '';
			document.getElementById('subscript').value = '';
			document.getElementById('subscriptposition').value = 'middle';
			this.color = color;

			actions.update();
		},

		// Remove the last added object
		undoObject: function() {
			this.objects.splice(this.objects.length-1,1);
			this.selected = -1;
		},

		// Delete the selected object
		deleteSelected: function() {
			if (this.selected >= 0) {
				this.objects.splice(this.selected,1);
				this.selected = -1;
			}
		},

		// Delete all objects
		resetObjects: function() {
			this.objects = [];
			this.selected = -1;
		},

		// Find the square object (if any) at the provided point (x,y)
		findSquareObject: function(x,y) {
			found = -1;

			for(var i=0;i<this.objects.length;i++) {
				if(this.objects[i].type=='square') {
					if (this.objects[i].x1 == x && this.objects[i].y1 == y) {
						found = i;
						break;
					}
				}
			}

			return found;
		},

		// Find the line object (if any) at the provided point (x,y).
		// This is done by calculating the distance from the point to the line.
		findLineObject: function(x,y) {
			found = -1;

			for(var i=0;i<this.objects.length;i++) {
				if(this.objects[i].type=='line') {

					// The distance calculation assumes an infinite line so
					// we need to make sure the point is actually near our
					// line
					x1=0;x2=0;y1=0;y2=0;

					if (this.objects[i].x1 <= this.objects[i].x2) {
						x1 = this.objects[i].x1;
						x2 = this.objects[i].x2;
					} else {
						x1 = this.objects[i].x2;
						x2 = this.objects[i].x1;						
					}

					if (this.objects[i].y1 <= this.objects[i].y2) {
						y1 = this.objects[i].y1;
						y2 = this.objects[i].y2;
					} else {
						y1 = this.objects[i].y2;
						y2 = this.objects[i].y1;						
					}

					if (x >= x1 && x <= x2 && y >= y1 && y <= y2) {
						dist = this.distanceToLine(this.objects[i].x1,
							this.objects[i].y1,this.objects[i].x2,
							this.objects[i].y2,x,y);
						if (dist < (global.spacing / 2)) {
							found = i;
							break;
						}
					}
				}
			}

			return found;			
		},

		// Distance from line (x1,y1,x2,y2) to a point (px,py)
		// Code based on:
		// http://developer.classpath.org/doc/java/awt/geom/Line2D-source.html
		distanceToLine: function(x1,y1,x2,y2,px,py) {
			pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);

      		x = 0.0;
      		y = 0.0;

      		if (pd2 == 0) {
          		// Points are coincident.
          		x = x1;
          		y = y2;
        	} else {
          		u = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / pd2;
          		x = x1 + (u * (x2 - x1));
          		y = y1 + (u * (y2 - y1));
        	}
  
 			distSquared = (x - px) * (x - px) + (y - py) * (y - py);

 			return Math.sqrt(distSquared);
    	},

    	// User updated the color on the toolbar
		updateColor: function(color) {
			this.color = color;

			if (this.selected >= 0) {
				this.objects[this.selected].color = color;
				actions.update();
			}
		},

		// User updated the label on the toolbar.  This is only relevant if an
		// object is selected.
		updateLabel: function(label) {
			if (this.selected >= 0) {
				this.objects[this.selected].label = label.trim();
				actions.update();
			}
		},

		// User updated the subscript on the toolbar.  This is only relevant
		// if an object is selected.
		updateSubscript: function(subscript) {
			if (this.selected >= 0) {
				this.objects[this.selected].sub = subscript.trim();
				actions.update();
			}
		},

		updateSubscriptPosition: function(position) {
			if (this.selected >= 0) {
				this.objects[this.selected].subpos = position;
				actions.update();
			}
		},

		// Update the map title
		updateTitle: function(title) {
			this.title = title.trim();
			actions.update();
		},

		// Select the specified object.  Also update the global color and
		// label values.
		selectObject: function(o) {
			this.selected = o;

			this.color = this.objects[o].color;
			document.getElementById('color').value = this.objects[o].color;
			document.getElementById('label').value = this.objects[o].label;
			document.getElementById('subscript').value = this.objects[o].sub;
			document.getElementById('subscriptposition').value = this.objects[o].subpos;

			actions.update();
		}
	}

	// UI actions
	actions = {
		// Redraw the whole page
		update: function() {
			canvas.redraw();
			this.restore();
		},

		// Redraw all the objects.
		restore: function() {
			// Draw lines first
			for(var i=0;i<global.objects.length;i++) {
				if(global.objects[i].type=='line') {
					if (i == global.selected) {
						// Highlight the selected line
						shape.highlight(global.objects[i]);
					}

					shape.draw(global.objects[i]);
				}
			}

			// Then draw squares
			for(var i=0;i<global.objects.length;i++) {
				if(global.objects[i].type=='square') {
					if (i == global.selected) {
						// Highlight the selected square
						shape.highlight(global.objects[i]);
					}

					shape.draw(global.objects[i]);
				}
			}

			// Finally, write the title
			if (global.title != undefined) {
				ctx.fillStyle = 'black';
				ctx.textAlign = 'left';
				ctx.textBaseline = 'top';
				ctx.font="bold 18px Arial";
				ctx.fillText(global.title,5,5);
			}
		},

		// Remove the last drawn object
		undo: function() {
			global.undoObject();
			this.update();
		},

		// Removed the selected object
		delete: function() {
			global.deleteSelected();
			this.update();
		},

		// Clear all the objects
		clear: function() {
			global.resetObjects();
/*
			for(var y=global.spacing;y<canvas.h;y=y+global.spacing*2) {
				for(var x=global.spacing;x<canvas.w;x=x+global.spacing*2) {
					shape.init(x,y);
					shape.done(x,y);
				}
			}
*/
			this.update();
		},

		// Export to PNG
		png: function() {
			// Remove the highlighted object first
			global.selected = -1;
			global.drawGraphPaper = false;
			this.update();

			window.open(canvas.toDataURL('image/png'), 'Save as PNG');

			global.drawGraphPaper = true;
			this.update();
		},

		// Save the map data to disk (in JSON format)
		save: function() {
			var textToWrite = JSON.stringify(global);
			var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});

			var downloadLink = document.createElement("a");

			if (global.title != undefined && global.title != '') {
				downloadLink.download = global.title + '.json';
			} else {
				downloadLink.download = 'mapper.json';
			}

			downloadLink.innerHTML = "Download File";
			if (window.webkitURL != null)
			{
				// Chrome allows the link to be clicked
				// without actually adding it to the DOM.
				downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
			}
			else
			{
				// Firefox requires the link to be added to the DOM
				// before it can be clicked.
				downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
				downloadLink.onclick = destroyClickedElement;
				downloadLink.style.display = "none";
				document.body.appendChild(downloadLink);
			}

			downloadLink.click();
		},

		// Load the map from disk
		load: function(files) {
    		var file = files[0];

      		var fileReader = new FileReader();
			fileReader.onload = function(fileLoadedEvent) 
			{
				var textFromFileLoaded = fileLoadedEvent.target.result;
				var data = JSON.parse(textFromFileLoaded);

				global.objects = data.objects;
				global.spacing = data.spacing;

				global.title = data.title;
				document.getElementById('title').value = global.title;

				actions.update();
			};
			fileReader.readAsText(file);
 		},

 		autoSubscript: function() {
 			var sorted = global.objects.slice(0);

 			sorted.sort(function(a,b) {
  				if (a.y1 < b.y1) return -1;
  				if (a.y1 > b.y1) return 1;
  				if (a.x1 < b.x1) return -1;
  				if (a.x1 > b.x1) return 1;
  				return 0;
			});

 			var subscript = 1;
 			for(var i=0;i<sorted.length;i++) {
				if(sorted[i].type=='square' && sorted[i].color=='Blue') {
					sorted[i].sub = subscript;
					subscript++;
				}
			}

			this.update();
		}
	}

	// Shape drawing functions
	shape = {
		x: 0, y: 0,

		// Called on mouse down event
		init: function(x,y) {
			this.x = this.squareCoord(x);
			this.y = this.squareCoord(y);
		},

		// Called on mouse up event
		done: function(x,y) {
			x2 = this.squareCoord(x);
			y2 = this.squareCoord(y);

			if (x2 == this.x && y2 == this.y) {
				// Mouse didn't move.  Either draw a square or select an
				// object.
				o = global.findSquareObject(x2,y2);
				if (o < 0) {
					o = global.findLineObject(this.lineCoord(x),
							this.lineCoord(y));
				}

				if (o < 0) {
					global.addObject(this.x,this.y,0,0,'square');
				} else {
					global.selectObject(o);
				}
			} else {
				// Mouse moved.  Draw line.
				global.addObject(this.lineCoord(this.x),this.lineCoord(this.y),
					this.lineCoord(x2),this.lineCoord(y2),'line');
			}
		},

		// Draw the specified shape
		draw: function(obj) {
			if(obj.color==undefined)
			{
				ctx.fillStyle = global.color;
				ctx.strokeStyle = global.color;
			} else {
				ctx.fillStyle = obj.color;
				ctx.strokeStyle = obj.color;
			}

			if (obj.type == 'square') {
				ctx.fillRect(obj.x1,obj.y1,global.spacing,global.spacing);

				if (label != undefined) {
					ctx.fillStyle = 'white'
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.font="bold 14px Arial";
					ctx.fillText(obj.label,obj.x1+global.spacing/2,
						obj.y1+global.spacing/2,global.spacing);
				}

				if (obj.sub != undefined) {
					ctx.fillStyle = 'black'
					ctx.textAlign = 'left';
					ctx.textBaseline = obj.subpos;
					ctx.font="9px Helvetica";
					ctx.fillText(obj.sub,obj.x1+global.spacing,obj.y1);
				}
			} else if (obj.type == 'line') {
      			ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(obj.x1,obj.y1);
				ctx.lineTo(obj.x2,obj.y2);
				ctx.closePath();
				ctx.stroke();

				if (label != undefined) {
					x = obj.x1+((obj.x2-obj.x1)/2);
					y = obj.y1+((obj.y2-obj.y1)/2);

					if (obj.y1 == obj.y2) {
						// Horizontal line
						y = y - 1;
						ctx.textAlign = 'center';
						ctx.textBaseline = 'bottom';
					} else if (obj.x1 == obj.x2) {
						// Vertical line
						x = x + 2;
						ctx.textAlign = 'left';
						ctx.textBaseline = 'middle';						
					} else {
						// Diagonal line
						x = x + 6;
						ctx.textAlign = 'left';
						ctx.textBaseline = 'middle';						
					}

					ctx.fillStyle = 'black'
					ctx.font="bold 14px Arial";
					ctx.fillText(obj.label,x,y);
				}
			}
		},

		// Draw a guide line
		guide: function(x,y) {
			actions.update();

			object = {
				x1: this.lineCoord(this.x),
				y1: this.lineCoord(this.y),
				x2: this.lineCoord(x),
				y2: this.lineCoord(y),
				type: 'line',
				color: 'Black',
				label: '',
				sub: '',
				subpos: 'middle'
			};

			this.draw(object);
		},

		// Highlight
		highlight: function(obj) {
      		ctx.lineWidth = 4;
      		ctx.strokeStyle = 'yellow';

      		ctx.beginPath();

      		if (obj.type == 'square') {
      			ctx.rect(obj.x1,obj.y1,global.spacing,global.spacing);
 			} else if (obj.type == 'line') {
				ctx.moveTo(obj.x1,obj.y1);
				ctx.lineTo(obj.x2,obj.y2);
				ctx.closePath();
      		}

      		ctx.stroke();
		},

		// Top left corner of square on our graph paper
		squareCoord: function(c) {
			var coord = c - (c % global.spacing);
			return coord;
		},

		// Center of square on our graph paper
		lineCoord: function(c) {
			var coord = this.squareCoord(c) + (global.spacing / 2);
			return coord;
		}
	}
	
	// Clear out everything
	canvas.clear = function() {
		ctx.clearRect(0,0,this.width,this.height);
	}

	// Redraw everything
	canvas.redraw = function() {		
		this.clear();
		
		if (global.drawGraphPaper) {
			// Prepare to draw the grid
			ctx.beginPath();
			ctx.strokeStyle = 'lightblue';
			ctx.lineWidth = 1;

			// Vertical rule
			for(var y=global.spacing;y<this.h;y=y+global.spacing) {
				ctx.moveTo(0,y);
				ctx.lineTo(this.w,y);
			}

			// Horizontal rule
			for(var x=global.spacing;x<this.w;x=x+global.spacing) {
				ctx.moveTo(x,0);
				ctx.lineTo(x,this.h);
			}

			// Draw the grid
			ctx.closePath();
			ctx.stroke();
		}

		// Restore any saved actions
		actions.restore();
	}


	canvas.onmousemove = function(e) {
		if(!e) var e = window.event;
		
		var x = e.clientX;
		var y = e.clientY;
		
		// If we're drawing a line, show the guide line
		if(this.mousedown)
			shape.guide(x,y);
	}


	canvas.onmousedown = function(e) {
		if(!e) var e = window.event;
		
		this.mousedown = true;
		
		var x = e.clientX;
		var y = e.clientY;

		shape.init(x,y);
	}


	canvas.onmouseup = function(e) {
		if(!e) var e = window.event;

		this.mousedown = false;
		
		var x = e.clientX;
		var y = e.clientY;

		shape.done(x,y);
	}
		
	// Now that all functions and objects are set, draw the grid
	canvas.redraw();
}
</script>

<style type="text/css">
body {
	margin: 0;
	overflow: hidden;	// No scrollbars, please
}

#canvas { z-index: 1; }

#toolset {
	z-index: 2;
	position: absolute;
	bottom: 10px;
	right: 10px;
	border: 1px solid #000;
	background-color: #fff;
	font-family: sans-serif;
	font-size: 90%;
	padding: 10px;
}

#toolset p {
	margin: 0;
	clear: both;
	line-height: 2em;
}

#toolset p label {
	font-weight: bold;
	width: 7em;
	float: left;
	display: inline-block;
}

#toolset p select {
	float: left;
	border: 1px solid #000;
	color: black;
	display: inline-block;
}

#toolset p textarea {
	float: left;
	border: 1px solid #000;
	color: black;
	display: inline-block;
}

</style>
</head>

<body onload="BodyLoad()">

<canvas id="canvas"></canvas>

<div id="toolset">
	<p>
		<button onclick="actions.undo()">Undo</button>
		<button onclick="actions.delete()">Delete</button>
		<button onclick="actions.clear()">Clear</button>
<!--		<button onclick="actions.autoSubscript()">Auto</button> -->
	</p>

	<p>
		<label>Color</label>
		<select id="color" onchange="global.updateColor(this.value)">
			<option selected>Black</option>
			<option>Red</option>
			<option>Orange</option>
			<option>Green</option>
			<option>Blue</option>
			<option>Purple</option>
		</select>
	</p>

	<p>
		<label>Label</label>
		<textarea id="label" onchange="global.updateLabel(this.value)" rows=1
			cols=12>
		</textarea>
	</p>

	<p>
		<label>Subscript</label>
		<textarea id="subscript" onchange="global.updateSubscript(this.value)" rows=1
			cols=12>
		</textarea>
	</p>

	<p>
		<label>Position</label>
		<select id="subscriptposition" onchange="global.updateSubscriptPosition(this.value)">
			<option selected>middle</option>
			<option>top</option>
			<option>bottom</option>
		</select>
	</p>

	<p>
		<label>Title</label>
		<textarea id="title" onchange="global.updateTitle(this.value)" rows=1
			cols=12>
		</textarea>
	</p>

	<p>
		<button onclick="actions.png()">Export</button>
		<button onclick="actions.save()">Save</button>
		<input type="file" id="load" name="files" style="width: 80px;" onchange="actions.load(this.files)"/>
	</p>

</div>

</body>
</html>
